## queues_intro_1

This lesson will introduce the queue abstract data structure and different ways to interact with it.

**Important**: If you haven't already completed [`stacks_intro_2`](../stacks_intro_2/README.md), please do that first.

---

### Concepts

![Queue Abstract Data Structure](assets/data_queue.png)

A queue is an abstract data structure that exposes at least two operations:
- `enqueue(element)` - appends an `element` to the back of the queue.
- `dequeue()` - removes the front `element` from the queue and returns it.

Together, these facilitate first-in-first-out (FIFO) operations:
the first thing `enqueue`d is the first thing `dequeue`d. Contrast this with a stack, which is last-in-first-out (LIFO).

Often, queues add additional helper operations that make their use easier, such as `peek()`, which returns the front `element` in the queue without removing it.

#### Quiz

- How would you examine items after the front of a queue?
- How would you cycle through items in a queue without permanently removing them?

---

### The `Queue` class

These exercises use a `Queue` class that exposes `.enqueue(value)`, `.dequeue()`, and `.peek()` methods as its interface. As with JavaScript's `Array` conventions, `.peek()` and `.dequeue()` will return `undefined` if the `Queue` is empty. Because of this, `Queue`s cannot hold `undefined` values and will throw an error if one is `.enqueue()`d. However, it _can_ hold other falsy values. For more details, please read the:
1. [Interface for the `Queue` class](../../structures/queue/interface.md)
1. [Tests that implementations must pass to meet the `Queue` interface](../../structures/queue/index.test.js)
1. [Simple `Queue` Implementation](../../structures/queue/simplified.js)

---

### Before You Begin

Be sure to check out a new branch (from `master`) for this exercise. Detailed instructions can be found [**here**](../../guides/before_each_exercise.md). Then navigate to the `exercises/queues_intro_1` directory in your terminal.

---

### Exercise

Do the following exercises in their respective files. For all of these warm-up exercises, you will use a single `Queue`, which is given to you. Do not use any data structures outside of that. Constant-size primitives (`undefined`, `null`, boolean, numbers, single characters (`'g'`), & symbols) are ok. Following each exercise, run the `npm test` command (from within the `exercises/queues_intro_1` directory) to verify it works.

_Note_: Given that these exercises are meant to a) build up familiarity with this data structure, and b) provide practice programming for high performance (the "Algorithms" in "Data Structures & Algorithms"), try to reduce any unnecessary steps the engine must execute, and please do not call any of your custom functions within these definitions.

#### Debugging Notes

While the test output generated by the `npm test` script describes how the exercises _should_ behave and the specific steps they're failing on, it may not tell you _exactly_ what's going on under the hood. To help with that, there are extra tools included to help with debugging:
- If you wish to experiment with either the provided data structures or your exercise solutions, the `npm run repl` script can be run within this directory to enter Node's interactive interpreter. It is the same interface you get when running the `node` command by itself (without specifying a file), except that the data structures and exercise exports are preloaded for you. That means you can jump straight into experimenting with them, without having to manually `require()` them first. However, anything that would cause the exercise scripts to crash (like syntax errors) needs to be fixed first.
- If you wish to see precisely why a test is failing, the `npm run test:debug` script can be run within this directory to enable breakpoints, statement-by-statement execution, and inspecting variables via VS Code's debugging environment (which is very similar to the Source tab on the Chrome inspector).

1. #### `getFront(queue)`
    In `get_front.js`, implement the `getFront(queue) -> value` function - With the given `queue`, get the front `value` without modifying the `queue`.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |

    | Context | Return Value |
    | --- | --- |
    | `queue` is empty. | `undefined` |
    | `queue` is not empty. | The front value of `queue`. |

    | Side Effect |
    | --- |
    | None: the `queue` should end up exactly how it started. |

    ##### Examples
    `queue` is empty
    ```js
    getFront(new Queue()); // returns: undefined
    ```

    `queue` is not empty
    ```js
    filledQueue;
    // contains, from front to back: 5, 3, 86, 12
    getFront(filledQueue); // returns: 5

    filledQueue;
    // contains, from front to back: 5, 3, 86, 12
    ```

1. #### `addToBack(queue, value)`
    In `add_to_back.js`, implement the `addToBack(queue, value)` function - Add the given `value` to the back of `queue`.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |
    | `value` | Any value. |

    | Return Value |
    | --- |
    | (none) |

    | Side Effect |
    | --- |
    | `value` is added to back of `queue`. |

    ##### Examples
    ```js
    const queue = new Queue();

    queue;
    // contains no values

    addToBack(queue, 36);
    addToBack(queue, 4);
    addToBack(queue, 13);

    queue;
    // contains, from front to back: 36, 4, 13
    ```

1. #### `takeFront(queue)`
    In `take_front.js`, implement the `takeFront(queue) -> value` function - Remove and return the front value from `queue`.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |

    | Context | Return Value |
    | --- | --- |
    | `queue` is empty. | `undefined` |
    | `queue` is not empty. | The front value of `queue`. |

    | Context | Side Effect |
    | --- | --- |
    | `queue` is not empty. | The front value is removed from `queue`. |

    ##### Examples
    `queue` is empty
    ```js
    const emptyQueue = new Queue();

    emptyQueue;
    // contains nothing
    takeFront(emptyQueue); // returns: undefined
    emptyQueue;
    // contains nothing
    ```

    `queue` is not empty
    ```js
    filledQueue;
    // contains, from front to back: 54, 23, 43, 25
    takeFront(filledQueue); // returns 54
    filledQueue;
    // contains, from front to back: 23, 43, 25
    ```

1. #### `isEmpty(queue)`
    In `is_empty.js`, implement the `isEmpty(queue) -> boolean` function - Test whether or not the given `queue` is empty.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |

    | Context | Return Value |
    | --- | --- |
    | `queue` is empty. | `true` |
    | `queue` is not empty. | `false` |

    | Side Effect |
    | --- |
    | None: the `queue` should end up exactly how it started. |

    ##### Examples
    `queue` is empty
    ```js
    isEmpty(new Queue()); // returns: true
    ```

    `queue` is not empty
    ```js
    filledQueue;
    // contains, from front to back: 3, 6, 3
    isEmpty(filledQueue); // returns: false

    filledQueue;
    // contains, from front to back: 3, 6, 3
    ```

1. #### `postpone(queue)`
    In `postpone.js`, implement the `postpone(queue)` function - Move the front value in `queue` to the back of `queue`.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |

    | Return Value |
    | --- |
    | (none) |

    | Context | Side Effect |
    | --- | --- |
    | `queue` is not empty. | The front value of `queue` is moved to the back of `queue`. |

    ##### Examples
    ```js
    filledQueue;
    // contains, from front to back: 6, 3, 7, 8, 3
    postpone(filledQueue);

    filledQueue;
    // contains, from front to back: 3, 7, 8, 3, 6
    ```

1. #### `take2nd(queue)`
    In `take_2nd.js`, implement the `take2nd(queue) -> value` function - Remove and return the value behind the front of `queue`, recycling the front value to the back of `queue`.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |

    | Context | Return Value |
    | --- | --- |
    | `queue` has 0 values. | `undefined` |
    | `queue` has 1 value. | The only value in `queue`. |
    | `queue` has at least 2 values. | The value behind the front value of `queue`. |

    | Context | Side Effect |
    | --- | --- |
    | `queue` has 1 value. | The value in `queue` is removed. |
    | `queue` has at least 2 values. | The front value in `queue` is moved to the back of `queue`. The next value is removed from `queue`. |

    ##### Examples
    `queue` has 0 values
    ```js
    emptyQueue;
    // contains no values
    take2nd(emptyQueue); // returns: undefined

    emptyQueue;
    // contains no values
    ```

    `queue` has 1 value
    ```js
    singleItemQueue;
    // contains, from front to back: 6
    take2nd(singleItemQueue); // returns: 6

    singleItemQueue;
    // contains no values
    ```

    `queue` has at least 2 values
    ```js
    multiItemQueue;
    // contains, from front to back: 1, 3, 4, 8, 2, 9, 6
    take2nd(multiItemQueue); // returns 3

    multiItemQueue;
    // contains, from front to back: 4, 8, 2, 9, 6, 1
    ```

1. #### `takeSmaller(numberQueue)`
    In `take_smaller.js`, implement the `takeSmaller(numberQueue) -> number` function - Remove and return the smaller of the first two values in the front of `queue`, recycling the other value to the back of `queue`.

    | Parameter | Argument |
    | --- | --- |
    | `numberQueue` | An instance of `Queue` containing only numbers. |

    | Context | Return Value |
    | --- | --- |
    | `numberQueue` has 0 values. | `undefined` |
    | `numberQueue` has 1 value. | The only value in `numberQueue`. |
    | `numberQueue` has at least 2 values. | The smaller of the two front values in `numberQueue`. |

    | Context | Side Effect |
    | --- | --- |
    | `numberQueue` has 1 value. | The value in `numberQueue` is removed. |
    | `numberQueue` has at least 2 values. | The smaller of the two front values in `numberQueue` is removed from `numberQueue`. The other value is moved to the back of `numberQueue`. |

    ##### Examples
    `numberQueue` has 0 values
    ```js
    emptyQueue;
    // contains no values
    takeSmaller(emptyQueue); // returns: undefined

    emptyQueue;
    // contains no values
    ```

    `numberQueue` has 1 value
    ```js
    singleNumberQueue;
    // contains, from front to back: 42
    takeSmaller(singleNumberQueue); // returns: 42

    singleNumberQueue;
    // contains no values
    ```

    `numberQueue` has at least 2 values and 1st value is smaller
    ```js
    multiNumberQueue;
    // contains, from front to back: 3, 4, 1, 8, 5
    takeSmaller(multiNumberQueue); // returns 3

    multiNumberQueue;
    // contains, from front to back: 1, 8, 5, 4
    ```

    `numberQueue` has at least 2 values and 2nd value is smaller
    ```js
    multiNumberQueue;
    // contains, from front to back: 4, 1, 8, 2, 6, 3
    takeSmaller(multiNumberQueue); // returns 1

    multiNumberQueue;
    // contains, from front to back: 8, 2, 6, 3, 4
    ```

1. #### `takeValueAtIndex(queue, index)`
    In `take_value_at_index.js`, implement the `takeValueAtIndex(queue, index) -> value` function - Remove and return the value located `index` from the front of `queue`. If `queue` is empty, return `undefined`.

    | Parameter | Argument |
    | --- | --- |
    | `queue` | An instance of `Queue`. |
    | `index` | A non-negative integer. |

    | Context | Return Value |
    | --- | --- |
    | `queue` is empty. | `undefined` |
    | `queue` is not empty. | The front value in `queue`, after recycling `index` front values to the back of queue. |

    | Context | Side Effect |
    | --- | --- |
    | `queue` is not empty. | `index` front values in `queue` are moved to the back of `queue`, then the next front value is removed from `queue`. |

    ##### Examples
    `queue` is empty
    ```js
    emptyQueue;
    // contains no values
    takeValueAtIndex(emptyQueue, 0); // returns: undefined

    emptyQueue;
    // contains no values
    ```

    `queue` is not empty
    ```js
    filledQueue;
    // contains, from front to back: 2, 6, 7, 8, 9, 2, 6, 0
    takeValueAtIndex(filledQueue, 3); // returns: 8

    filledQueue;
    // contains, from front to back: 9, 2, 6, 0, 2, 6, 7
    ```

    `queue` is not empty, with wrapping
    ```js
    filledQueue;
    // contains, from front to back: 0, 1, 2
    takeValueAtIndex(filledQueue, 7); // returns: 1

    filledQueue;
    // contains, from front to back: 2, 0
    ```

1. #### `takeNextSmallest(numberQueue)`
    In `take_next_smallest.js`, implement the `takeNextSmallest(numberQueue) -> number` function - Remove and return the first number in `numberQueue` which is not bigger than the number following it, recycling each number before it to the back of `numberQueue`.

    | Parameter | Argument |
    | --- | --- |
    | `numberQueue` | An instance of `Queue` containing only numbers. |

    | Context | Return Value |
    | --- | --- |
    | `numberQueue` has 0 values. | `undefined` |
    | `numberQueue` has 1 value. | The only value in `numberQueue`. |
    | `numberQueue` has at least 2 values. | The first number in `numberQueue` which is `<=` the number following it. |

    | Context | Side Effect |
    | --- | --- |
    | `numberQueue` has 1 value. | The value in `numberQueue` is removed. |
    | `numberQueue` has at least 2 values. | Each number on the front of `numberQueue` which is larger than the number following it is moved to the back of `numberQueue`. The first number which is not larger than the number following it is removed from `numberQueue`. |

    ##### Examples
    `numberQueue` has 0 values
    ```js
    emptyQueue;
    // contains no values
    takeNextSmallest(emptyQueue); // returns: undefined

    emptyQueue;
    // contains no values
    ```

    `numberQueue` has 1 value
    ```js
    singleNumberQueue;
    // contains, from front to back: 54
    takeNextSmallest(singleNumberQueue); // returns: 54

    singleNumberQueue;
    // contains no values
    ```

    `numberQueue` has at least 2 values
    ```js
    multiNumberQueue;
    // contains, from front to back: 8, 7, 6, 4, 5, 3, 2, 2
    takeNextSmallest(multiNumberQueue); // returns 4

    multiNumberQueue;
    // contains, from front to back: 5, 3, 2, 2, 8, 7, 6
    takeNextSmallest(multiNumberQueue); // returns 2

    multiNumberQueue;
    // contains, from front to back: 2, 8, 7, 6, 5, 3
    takeNextSmallest(multiNumberQueue); // returns 2

    multiNumberQueue;
    // contains, from front to back: 8, 7, 6, 5, 3
    takeNextSmallest(multiNumberQueue); // returns 3

    multiNumberQueue;
    // contains, from front to back: 8, 7, 6, 5
    ```

---

### Submitting Your Solution

When your solution is complete, return to the root of your `data_structures_lessons` directory. Then commit your changes, push, and submit a Pull Request on GitHub. Detailed instructions can be found [**here**](../../guides/after_each_exercise.md).

### Next Steps

Start working on the [`queues_intro_2` exercises](../queues_intro_2/README.md) while waiting for feedback on your pull request.
